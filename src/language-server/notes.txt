instruction_type
tokens length
-> {instruction_type} requires {tokens_length} - 1 operands

dict instruction patterns:
{instruction: [type, type, type]}

type â‚¬ ("number", "register")

funktion:
isValidtype(type:string, value: string): bool {
    if type === "number" {
        return isValidNumber(value)
    }
    else if type === "register" {
        return isValidRegister(value)
    }
}

isValidRegister(register: string) {


}

                // Verify num of operands
                if tokens.length !== instructionSet[instructionType].length + 1
                    message: {instructionType} requires instructionSet[instructionType].length operands.

                // Verify tokens
                valid = false;
                for i in instructionSet[instructionType] {
                    if type is type of options:

                }
                if !valid: push diagnostics

                    diagnostics.push({
                        severity: DiagnosticSeverity.Error,
                        range: {
                            start: { line: index, character: 0 },
                            end: { line: index, character: instruction.length }
                        },
                        message: `STORE instructions require one operand.`,
                        source: 'reti'
                    });
       
    connection.sendDiagnostics({ uri: textDocument.uri, diagnostics });


                            if(tokens[1].startsWith('-')) {
                            diagnostics.push({
                                severity: DiagnosticSeverity.Warning,
                                range: {
                                    start: { line: index, character: tokens[0].length + 1 },
                                    end: { line: index, character: tokens[0].length + tokens[1].length + 1 }
                                },
                                message: `Immediate will be treated as unsigned. Negative numbers might not behave as expected.`,
                                source: 'reti'
                            });
                        }
                    }}

                    // No valid opcode found at start of the line.
            else {
                diagnostics.push({
                    severity: DiagnosticSeverity.Error,
                    range: {
                        start: { line: index, character: 0 },
                        end: { line: index, character: tokens[0].length }
                    },
                    message: `Unknown instruction ${tokens[0]}.`,
                    source: 'reti'
                });
            }




_________________

num of tokens
valid instructions
valid operands
warnings for negative when unsigned


                           diagnostics.push({
                                severity: DiagnosticSeverity.Warning,
                                range: {
                                    start: { line: index, character: tokens[0].length + 1 },
                                    end: { line: index, character: tokens[0].length + tokens[1].length + 1 }
                                },
                                message: `Immediate will be treated as unsigned. Negative numbers might not behave as expected.`,
                                source: 'reti'
                            });

autocompletion
onHover